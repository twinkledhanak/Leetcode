/**
Height and Depth can be measured as - no of nodes // no of edges

Time complexity: We see how many nodes we traverse for the entire tree, so, O(n) = n => no of nodes

For remaining cases, 
for depth function - no of nodes        => if (root == null) return 0
longestPath & diameter - no of nodes    => if (root == null) return 0

for height function - no of edges       => if (root == null) return 0
BalancedTree function - no of edges     => if (root == null) return -1
(since it also uses height function)

*/

1. Calculate Maximum Depth
public int maxDepth(TreeNode root) {
    if (root == null) { // we consider no of nodes, so return 0, not -1
      return 0;
    } 
    else { // ********* Remember the else here!!!!!
      int left_height = maxDepth(root.left);
      int right_height = maxDepth(root.right);
      return java.lang.Math.max(left_height, right_height) + 1;
    }
}

2. Usually when we traverse an entire binary tree, we go through all the nodes of tree once 
Time Complexity: Height of tree: O(n) , where n = no of nodes 
In worst case, n = n, so Height is also n, O(n)
In best case, n = logN, so Height is also logN, O(logN)

3. Check if the tree is balanced 
Math.abs(height(left)-height(right)) < 2 && isBalanced(root.left) && isBalanced(root.right)

public int height(TreeNode root){
        // no of edges
        if(root == null)
            return -1; // ********************************************@#$%^&*()

        if(root.left ==null && root.right==null)
            return 0;

        return Math.max(height(root.left),height(root.right)) + 1;    

    }



4. Diameter of Binary Tree
// The leetcode example considers diameter to be measured as No of edges - [4,2,1,3] => have 3 edges total
// So, diameter of this array = 3

class Solution {
    private int diameter;
    public int diameterOfBinaryTree(TreeNode root) {
        diameter = 0;
        longestPath(root);
        return diameter;
    }

    // The return value of this function is a height, but it is not used anywhere. We just calculate both height and diameter
    // diameter is a class level variable that is updated by this function. Height is returned but not used
    private int longestPath(TreeNode node){
        if(node == null) return 0;
        // recursively find the longest path in
        // both left child and right child
        int leftPath = longestPath(node.left);
        int rightPath = longestPath(node.right);

        // update the diameter if left_path plus right_path is larger
        diameter = Math.max(diameter, leftPath + rightPath);

        // return the longest one between left_path and right_path;
        // remember to add 1 for the path connecting the node and its parent
        return Math.max(leftPath, rightPath) + 1; // since we start from root.left and root.right
    }
}