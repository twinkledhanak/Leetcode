// Example

      1
    /   \
    2   3   
  /  \
 4    5

Inorder: 4,2,5,1,3 // Only inorder of BST will give sorted array
Preordr: 1,2,4,5,3 (another variant of DFS) +ab
Postord: 4,5,2,3,1
BFStrav: 1,2,3,4,5 (level order), different from Preorder

Types of Traversal:

1. Inorder (Some distant variant of DFS as I cannot write it using BFS)
2. Preorder (Variant of DFS traversal)
3. Postorder (Some distant variant of DFS as I cannot write it using BFS)
4. Level order (Strictly BFS)

Inorder traversal is not a unique identifier of BST. At the same time, both preorder and postorder traversals are unique identifiers of BST.

Ways to write a traversal code:
1. Iterative (Time Efficient, we use stacks to store full context)
2. Recursive (Intuitive and Easy)
3. Morris (Space Efficient, we just use right node values to store location of next parent node (not our own parent) we have to go )

4. Just traversing as needed (without stacks or queues)


Ways to traverse a Binary tree:
-------------------------------------------------------------------------------------------------
Iterative                                   Iterative                               Recursive
(Using DFS)                                 (Using BFS)
-------------------------------------------------------------------------------------------------
Inorder(Stack)(Y)                            -                                        Inorder(Y)
Preorder(LL,plast)(Y)                        -                                        Preorder(Y)
Postorder(LL,plast)(Y)                       -                                        Postorder(Y)
    -                                        LevelOrder(Y)                            LevelOrder(Y)(Sim to RHS view)


ONLY Postorder uses reverse(), in pre - we ourselves reverse it 

Ways to traverse a N-ary tree:
-------------------------------------------------------------------------------------------------
Iterative                       Iterative                               Recursive
(Using DFS)                     (Using BFS)
-------------------------------------------------------------------------------------------------
Inorder                         Level Order (Queue using LL,poll)(Y)
Preorder(LL)(Y)(*)                
Postorder(LL)(Y)(*)


* Both uses Collections.reverse() but their order is different
* They both use LL, so we have pollLast()

// POST-ORDER TRAVERSAL CODE THAT MIGHT NOT LOOK LIKE POST-ORDER

WE ARE USED TO SEEING IT AS: AB+
PROCESSING THE LEFT, THE RIGHT AND THEN DOING SOMETHING WITH THE NODE

BUT,
WE CAN ALSO HAVE EXAMPLE OF FUNCTIONAL POST ORDER TRAVERSAL

REFER TO THIS QUESTION:
MAXIMUM PATH SUM IN A TREE (SIMILAR TO KADANE BUT TO BE APPLIED ON A TREE)





Balanced trees are usually balanced in two areas - 

Height-balanced
For each node in the tree, the difference in height between its left and right subtrees is no more than one. The height of an empty subtree is -1. The height difference is calculated by subtracting the absolute value of the left subtree from the absolute value of the right subtree, or vice versa. 


Weight-balanced
For each node in the tree, the difference in the number of inner nodes in its left and right subtrees is no more than one.