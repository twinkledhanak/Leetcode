/*
https://leetcode.com/discuss/interview-question/5456298/Citadel-Software-Engineering-Campus-Assesment
A data processing pipeline consists of n services connected in a series where the output of the ith service serves as the input to the (i+ 1)th service. However, the processing units have varying latencies, and the throughput of the ith unit is represented by the array throughput[i] in messages per minute. The first service receives input through an API, and the nth service produces the final output.

Each service can be scaled up independently, with the cost of scaling up the ith service one unit equal to scaling_ cost[i]. After scaling up a service x times, it can process throughput[i]*(1 + x) messages per minute.

Given the arrays throughput and scaling_ cost, both of size n, and an integer budget representing the budget available, determine the optimal scaling configuration for the services such that the throughput generated by the nth service is maximized.

For instance, throughput = [4, 2, 7], scaling_cost = [3, 5, 6], and budget = 32.
To maximize the throughput of the final service, an optimal solution is:

Service index	scale from	scale to	Times scaled	cost per scaling	total cost
0	4	12	2	3	6
1	2	10	4	5	20
2	7	14	1	6	6
When these units are applied in series they generate a throughput of 10 units, the maximum possible throughput given the budget, hence the answer is 10

*/


import java.util.PriorityQueue;

class Service {
    int index;
    double improvementPerCost;

    Service(int index, double improvementPerCost) {
        this.index = index;
        this.improvementPerCost = improvementPerCost;
    }
}

public class MaxPipelineThroughput {
    
    public static int maxPipelineThroughput(int[] throughput, int[] scalingCost, int budget) {
        int n = throughput.length;
        int[] scales = new int[n];
        PriorityQueue<Service> pq = new PriorityQueue<>((a, b) -> Double.compare(b.improvementPerCost, a.improvementPerCost));
        
        // Calculate initial improvements and add to priority queue
        for (int i = 0; i < n; i++) {
            double improvement = (double) throughput[i] / scalingCost[i];
            pq.add(new Service(i, improvement));
        }
        
        // Scale services while budget allows
        while (budget > 0 && !pq.isEmpty()) {
            Service bestService = pq.poll();
            int i = bestService.index;
            
            if (budget >= scalingCost[i]) {
                budget -= scalingCost[i];
                scales[i]++;
                
                // Recalculate the improvement and add back to the queue
                double newImprovement = (double) throughput[i] * (1 + scales[i]) / scalingCost[i];
                pq.add(new Service(i, newImprovement));
            } else {
                break; // Not enough budget to scale further
            }
        }
        
        // Calculate the minimum throughput after scaling
        int minThroughput = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            minThroughput = Math.min(minThroughput, throughput[i] * (1 + scales[i]));
        }
        
        return minThroughput;
    }
    
    public static void main(String[] args) {
        int[] throughput = {4, 2, 7};
        int[] scalingCost = {3, 5, 6};
        int budget = 32;
        System.out.println(maxPipelineThroughput(throughput, scalingCost, budget)); // Output: 10
    }
}
